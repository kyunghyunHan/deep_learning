use ndarray::prelude::*;

/*
 퍼셉트론
 퍼셉트론은 신경망(딥러닝)의 기원이 되는 알고리즘 입니다.
 그렇기 때문에 퍼셉트론의 구조를 배우는 것은 신경망과 딥러닝으로 나아가는데 중요합니다.

 퍼셉트론이란

 퍼셉트론은 다수의 신호를 입력받아 하나의 신호를 출력합니다.
 전류가 전선을 타고 흐르는 전자를 내보내듯 퍼셉트론 신호도 흐름을 만들고 정보를 앞으로 전달합니다.
 다만 실제 전류와 달리 퍼셉트론은 흐른다/안흐른다(1이나 0)의 두가지 값을 가질수 있습니다.

 입력으로 2개의 신호를 받은 퍼셉트론은 x₁ 와 x₂ 는 입력신호,y는 출력신호 w₁ 와 w₂는 가중치를 뜻합니다. 원을 뉴런 또는 노드라고 불립니다.
 입력신호가 뉴런에 보내질떄는 각각 고유한 가중가 곱해집니다.(x₁w₁,x₂w₂) 뉴런에서 보내온 총합이 정해진 한계를 넘어설 때만 1을 출력합니다.(이를 뉴런이 활성화 된다 라 표현하기도 합니다.)
 그 한계를 임계값 이라하며 ⍬기호로 나타냅니다.
 수식으로 나타내면 이와 같습니다.

 퍼셉트론은 복수의 입력신호 각각에 고유한 가중치를 부여합니다.가중치는 각 신호가 결과에 주는 영향력을 조절하는 요소로 작용합니다.
 가중치가 클수록 해당 신호가 그만큼 더 중요해집니다.

 가중치는 전류에서 말하는 저항에 해당댑니다.
 저항은 전류의 흐름을 억제하는 매개변수로 저항이 낮을수록 큰 전류가 흐릅니다.
 퍼셉트론의 가중치는 그 값이 클수록 강한 신호를흘려보냅니다.
 이처럼 서로 작용하는 방향은 다르지만 신호가 얼마나 잘 흐르는가를 통제하는 점에서 비슷한기능을합니다.

 AND게이트
And게이트는 입력이둘이고 출력은 하나입니다.
이와 같은 입력 신호와 출력신호의 대응표를 진리표 라고합니다.
AND게이트의 진리표로 두 입력이 모두 1일떄만 1을 출력하고 그외에는 0을 출력합니다.

AND게이트를 퍼셉트론으로 표현하려면  진리표대로 작동하는 w₁ 와 w₂,⍬의 값을 정하는 것입니다.

매개 변수 조합은 무한히 많습니다.
가령(w₁ , w₂ , ⍬) 가 (0.5,0.5,0,7) 일떄 또 (0.5,0.5,0,8) 일때 모두 AND게이트의 조건을 만족합니다.
매게변수를 이렇게 설정하면 x₁ 와 x₂ 모두가 1일떄만 가중 신호의 총합이 주어진 임계값을 웃돌게 됩니다.

NAND게이트

NAND는 Not AND를 의미하며 그 동작은 AND게이트의 출력을 뒤집은 것이 됩니다.
진리표를 보면 x₁ 와 x₂ 모두가 1일떄만 0을 출력하고 나머지는 1을 출력합니다.


NAND게이트를 표현하려면 (w₁ , w₂ , ⍬) =(-0.5,-0.5,-0,7)가 될수 있습니다.
부호를 모두 반전시키면 NAND가 될수 있습니다.
OR게이트
입력신호중 하나 이상이 1이면출력이 1이되는 논리 회로입니다.

이상과 같이 퍼셉트론으로 AND,NAND,OR논리 회로를 표현할수 있습니다.
중요한점은 퍼셉트론의 구조는 AND,NAND,OR게이트 모두에서 똑같다는 것입니다.
세가지 게이트에서 다른것은 매개변수의 값(가중치와 임계값) 뿐입니다.

AND구현

매개변수 w1,w2,theta는 함수안에서 초기화 하고 가중치를 곱한 입력의 총합이 임곗값을 넘으면 1을 반환하고 그외에는 0을반환합니다.


NAND와 OR도 비슷하게 구현을 할수있지만 다른 방법으로 수정할수 있습니다.

⍬ 를 -b로 치환하면 퍼셉트론의 동작이 다음과 같이 됩니다.기호만 변경되었 을 뿐 의미는 같습니다.
여기에서 b를 편향이라하며 w1,w2는 그대로 가중치 입니다.퍼셉트론은 입력신호에 가중치를 곱한 값과 편향값을 합하여 
그 값이 0을 넘으면 1을 출력하고 그렇지 않으면 0을 출력합니다.

계산

벡터 끼리의 곱셈은 두배열의 원소 수가 같다면 가 원소끼리 곱합니다.
그렇기 때문에 w*x에서는 인덱스가 같은 원소끼리 곱합니다.
또 sum메서드 에서는 입력한 배열에 담긴 모든 원소의 총합을 계산합니다.
이 가중치에 편향을 더하면 계산이 완료됩니다.

가중치와 편향을 도입한 AND게이트는 다음과 같습니다.

여기에서  -⍬가 편향 b로 치환되었습니다. 그리고 편향은 가중치 w₁,w₂와 기능이 다르다는 사실에 주의해야 합니다.
w₁,w₂ 는 각 입력신호가 결과에 주는 영향력을 조절하는 매개변수 이고 편향은 뉴런이 얼마나 쉽게 활성화 (결과를 1을 출력)
하느냐를 조정하는 매개변수 입니다.예로 b가 -0.1이면 각 입력신호에 가중치를 곱한 값들의 합이 0.1을 초과할떄만 뉴런이 활성화 됩니다.
b가 -20.0이면 각 입력 신호에 가중치를 곱한 값들의 합이 20.0을 넘지 않으면 뉴런이 활성화 되지 않습니다.
이처럼 편향의 값은 뉴런이 얼마나 활성화 되는지를 결정합니다.

NAND와 OR

XOR 

XOR게이트는  베타적 논리합이라는 논리 회로 입니다.
x₁ 과  x₂중 한쪽이 1일때만 1을 출력합니다.
지금까지의 퍼셉트론으로는 구현할수 없습니다.

OR게이틑 살펴보면 매개변수 (b,w₁,w₂) = (-0.5,1.0,1.0) 의 일떄 진리표를 만족합니다.
이떄의 퍼셉트론은 다음과 같습니다.

퍼셉트론은 직선으로 나뉜 두 영역을만듭니다.
직선으로 나뉜 한쪽 영역은 1을 출력하고 다른 한쪽은 0을 출력합니다. 다음과 같습니다.

OR게이트는 (x₁,x₂) = (0,0) 일떄 0을 출력하고 (0,1) ,(1,0),(1,1) 일떄는 1을 출력합니다.
0을 o ,1을 삼각형 ▴ 으로 표시했습니다.OR게이트를 만들려면  o 와 ▴을 직선으로 나누어야 합니다.

OR처럼 직선하나로 o 와 ▴을 나누는 영역을 만들려면 직선이라는 제약을 없애야 합니다. 

퍼셉트론은 직선하나로 나눈 영역만 표시할수 있다는 한계가 있습니다.
위와 같은 곡선의 영역을 비선형 영역,직선의 영역을 선형 영역 이라고 합니다.

퍼셉트론으로는 XOR게이트를 표현할수는 없습니다.
하지만 층을 쌓아 다층 퍼셉트론은 만들수 있습니다.

XOR게이트를 만드는 방법은 다양합니다.
그중 하나는 조합을 하는 방법입니다.
AND,NAND,OR게이트를 다음과 같이 표현합니다.
NAND게이트에 있는 o는 출력을 반전한다는 뜻입니다.

XOR게이트는 ?부분에 세가지 게이트를 하나씩 대입하면 XOR을 완성할수 있습니다.



다음과 같은 조합이라면 XOR을 구현할수 있습니다.
x₁,x₂가 입력신호 y가 출력신호입니다.x₁,x₂는 NAND와 OR의 입력이 되고 NAND와 OR의 출력이 AND게이트의 입력으로 이어집니다.

NAND의 출력을 s₁,OR의 출력을 s₂로 해서 진리표를 만들면 다음과 같습니다.


구현

구현한 XOR을 뉴런을 이용한 퍼셉트론으로 표현하면 다음과 같습니다.

XOR은 다층 구조의 네트워크 입니다.왼쪽부터 0층 ,1층,2층 으로 가정하겟습니다.
XOR의 퍼셉트론과AND OR의 퍼셉트론의 형태가 다릅니다.AND,OR이 단층인 반면 XOR은 2층 퍼셉트론입니다.
이처럼 층이 여러개인 퍼셉트론을 다층 퍼셉트론이라 합니다.

2충 퍼셉트론에서는 0층에서 1층으로 신호가 전달되고 1층에서 2층으로 신호가전달됩니다.동작을 서술하면
1.0층의 두 뉴런이 입력신호를 받아 1층의 뉴런으로 신호를 보낸다
2.1층의 뉴런이 2층의 뉴런으로 신호를 보내고 2층의 뉴런은 y를 출력한다.

다층 퍼셉트론은 단층 퍼셉트론으로는 표현하지 못한 것을 층을 하나 늘려 구할수 있었습니다.

NAND에서 컴퓨터까지

다층 퍼셉트론은 복잡한회로로 덧셈을 처리하는 가산기(덧셈과 뻇셈만 할수 있는 계산기)2진수를 10진수로 변환하는 인코더 ,어떤 조건을 충족하면 1을 출력하는 회로및 컴퓨터도 만들수 있습니다.

컴퓨터는 마치 퍼셉트론처럼 입력과 출력으로 구성된 특정 규칙대로 계산을 수행합니다.

컴퓨터 내부에서 이뤄지는 처리가 매우 복잡할것 같지만 NAND게이트 조합만으로 컴퓨터가 수행하는 일을 재현할수 있습니다.

이처럼 다층 퍼셉트론은 2층 퍼셉트론이면 컴퓨터를 만들수 있습니다. 정확히는 비선형인 시그모이드 함수를 활성화 함수로 이용하면 임의의 함수를 표현할수 있다는 사실이 증명되었습니다.

이는 퍼셉트론은 층을 거듭 쌓으면 비선형적인 표현도 가능하고 이론상 컴퓨터가 수행하는 처리도 모두 표현할수 있다는 점을 알수 있습니다.




*/
 pub fn main(){
    //입력
    let x= arr1(&[0.0,1.0]);
    //가중치
    let w= arr1(&[0.5,0.5]);
    //편향
    let b= -0.7;
//    println!("{}",&w*&x);
//    println!("{}",(&w*&x).sum());
//    println!("{}",(&w*&x).sum()+b)//대략 0.2

    // println!("{}",and2(0.0,0.0));//0을 출력
    // println!("{}",and2(1.0,0.0));//0을 출력
    // println!("{}",and2(0.0,1.0));//0을 출력
    // println!("{}",and2(1.0,1.0));//1을 출력


    println!("{}",xor(0.0,0.0));//0을 출력
    println!("{}",xor(1.0,0.0));//0을 출력
    println!("{}",xor(0.0,1.0));//0을 출력
    println!("{}",xor(1.0,1.0));//1을 출력


}
// fn and(x1:f64,x2:f64)->i32{
//     let  w1= 0.5;
//     let  w2= 0.5;
//     let  theta= 0.7;
//     let  tmp=  x1*w1 +x2*w2;
//     if tmp <=theta{
//         return 0;
//     }else{
//         return 1
//     }
// }

fn and(x1:f64,x2:f64)->i32{
    let  x= arr1(&[x1,x2]);
    let  w= arr1(&[0.5,0.5]);
    let b: f64= -0.7;
    let tmp = (w*x).sum()+b;
    if tmp <=0.0 {
        return 0
    }else {
        return 1
    }
    
}

fn nand(x1:f64,x2:f64)->i32{
    let x= arr1(&[x1,x2]);
    let w= arr1(&[-0.5,-0.5]);//AND와는 가중치만 다르다.
    let b: f64=  0.7;
 
    let tmp = (w*x).sum()+b;
    if tmp <=0.0 {
        return 0
    }else {
        return 1
    }
}

fn or(x1:f64,x2:f64)->i32{
    let x= arr1(&[x1,x2]);
    let w= arr1(&[0.5,0.5]);//AND와는 가중치만 같다
    let b: f64= -0.2;
    let tmp = (w*x).sum()+b;

    if tmp <=0.0 {
        return 0
    }else {
        return 1
    }
}
fn xor(x1:f64,x2:f64)->i32{
   let s1= nand(x1, x2);
   let s2= or(x1, x2);
   let y= and(s1 as f64, s2 as f64);
   return y
}
