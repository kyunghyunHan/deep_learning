use ndarray::prelude::*;

/*
 퍼셉트론
 퍼셉트론은 신경망(딥러닝)의 기원이 되는 알고리즘 입니다.
 그렇기 때문에 퍼셉트론의 구조를 배우는 것은 신경망과 딥러닝으로 나아가는데 중요합니다.

 퍼셉트론이란

 퍼셉트론은 다수의 신호를 입력받아 하나의 신호를 출력합니다.
 전류가 전선을 타고 흐르는 전자를 내보내듯 퍼셉트론 신호도 흐름을 만들고 정보를 앞으로 전달합니다.
 다만 실제 전류와 달리 퍼셉트론은 흐른다/안흐른다(1이나 0)의 두가지 값을 가질수 있습니다.

 입력으로 2개의 신호를 받은 퍼셉트론은 x₁ 와 x₂ 는 입력신호,y는 출력신호 w₁ 와 w₂는 가중치를 뜻합니다. 원을 뉴런 또는 노드라고 불립니다.
 입력신호가 뉴런에 보내질떄는 각각 고유한 가중가 곱해집니다.(x₁w₁,x₂w₂) 뉴런에서 보내온 총합이 정해진 한계를 넘어설 때만 1을 출력합니다.(이를 뉴런이 활성화 된다 라 표현하기도 합니다.)
 그 한계를 임계값 이라하며 ⍬기호로 나타냅니다.
 수식으로 나타내면 이와 같습니다.

 퍼셉트론은 복수의 입력신호 각각에 고유한 가중치를 부여합니다.가중치는 각 신호가 결과에 주는 영향력을 조절하는 요소로 작용합니다.
 가중치가 클수록 해당 신호가 그만큼 더 중요해집니다.

 가중치는 전류에서 말하는 저항에 해당댑니다.
 저항은 전류의 흐름을 억제하는 매개변수로 저항이 낮을수록 큰 전류가 흐릅니다.
 퍼셉트론의 가중치는 그 값이 클수록 강한 신호를흘려보냅니다.
 이처럼 서로 작용하는 방향은 다르지만 신호가 얼마나 잘 흐르는가를 통제하는 점에서 비슷한기능을합니다.

 AND게이트
And게이트는 입력이둘이고 출력은 하나입니다.
이와 같은 입력 신호와 출력신호의 대응표를 진리표 라고합니다.
AND게이트의 진리표로 두 입력이 모두 1일떄만 1을 출력하고 그외에는 0을 출력합니다.

AND게이트를 퍼셉트론으로 표현하려면  진리표대로 작동하는 w₁ 와 w₂,⍬의 값을 정하는 것입니다.

매개 변수 조합은 무한히 많습니다.
가령(w₁ , w₂ , ⍬) 가 (0.5,0.5,0,7) 일떄 또 (0.5,0.5,0,8) 일때 모두 AND게이트의 조건을 만족합니다.
매게변수를 이렇게 설정하면 x₁ 와 x₂ 모두가 1일떄만 가중 신호의 총합이 주어진 임계값을 웃돌게 됩니다.

NAND게이트

NAND는 Not AND를 의미하며 그 동작은 AND게이트의 출력을 뒤집은 것이 됩니다.
진리표를 보면 x₁ 와 x₂ 모두가 1일떄만 0을 출력하고 나머지는 1을 출력합니다.
NAND게이트를 표현하려면 (w₁ , w₂ , ⍬) =(-0.5,-0.5,-0,7)가 될수 있습니다.
부호를 모두 반전시키면 NAND가 될수 있습니다.
OR게이트
입력신호중 하나 이상이 1이면출력이 1이되는 논리 회로입니다.

이상과 같이 퍼셉트론으로 AND,NAND,OR논리 회로를 표현할수 있습니다.
중요한점은 퍼셉트론의 구조는 AND,NAND,OR게이트 모두에서 똑같다는 것입니다.
세가지 게이트에서 다른것은 매개변수의 값(가중치와 임계값) 뿐입니다.

AND구현





*/
pub fn main(){
    println!("{}",and2(0.0,0.0));//0을 출력
    println!("{}",and2(1.0,0.0));//0을 출력
    println!("{}",and2(0.0,1.0));//0을 출력
    println!("{}",and2(1.0,1.0));//1을 출력
}
fn and(x1:f64,x2:f64)->i32{
    let  w1= 0.5;
    let  w2= 0.5;
    let  theta= 0.7;
    let  tmp=  x1*w1 +x2*w2;
    if tmp <=theta{
        return 0;
    }else{
        return 1
    }
}

fn and2(x1:f64,x2:f64)->i32{
    let  x= arr1(&[x1,x2]);
    let  w= arr1(&[0.5,0.5]);
    let b= -0.7;
    // let mut tmp= ndarray::sum
    let tmp = (&w * &x).sum()+b;
    if tmp <=0.0 {
        return 0
    }else {
        return 1
    }
    
}
fn xor(){}
