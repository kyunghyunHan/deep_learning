use ndarray::prelude::*;
/*
신경망

가장 왼쪽 끝을 입력층 중간을 은닉충, 오른쪽 끝을 출력층 이라고 합니다.
은닉층의 뉴런은 눈에 보이지 않습니다.그렇기 떄문에 은닉입니다.

위는 x₁과 x₂라는 두 신호를 입력받아 y를 출력받는 퍼셉트론입니다.
이 퍼셉트론을 수식으로 나타내면 다음과 같습니다.

b는 편향을 나타내며,뉴런이 얼마나 쉽게 활성화 되느냐를 제어합니다.한편 W₁와 w₂는 각 신호의 가중치를 나타내는 매개변수로 각 신호의 영향력을 제어합니다.
그런데 위에는 편향 b가 보이지 않습니다.편향을 명시한다면 다음과 같습니다.

가중치가 b이고 입력이 1인 뉴런이 추가되었습니다.이 퍼셉트론의 동작은 x₁,x₂,1이라는 3개의 신호가 뉴턴에 입력되어 각 신호에 가중치를 곱한 후 다음 뉴런에 전달됩니다.
다음 뉴런에서는 이 신호들의 값을 더하여 그합이 0을 넘으면 1을 출력하고 그렇지 않으면 0을 출력합니다.
편향의 입력신호는 항상 1이기 때문에 그림에서는 해당 뉴런을 회색으로 채워 다른 뉴런과 구별했습니다.

간결한 형태로 다시 작성하면 조건분기의 동작(0을 넘으면 1을출력 그렇지 않으면 0을 출력)을 하나의 함수로 나타냅니다.이 함수를 h(x)라 하면 다음과 같이 표현 가능합니다.


입력 신호의 총합이 h(x)라는 함수를 거쳐 반환되어 그 변환된 값이 y의 출력이 됨을 보여줍니다.
h(x)함수는 입력이 0을 넘으면 1을 돌려주고 그렇지 않으면 0을 돌려줍니다.




*/

/*활성화 함수
h(x)처럼 입력신호의 총합을 출력신호로 변환하는 함수를 일반적으로 활성화 함수 라 합니다.
활성화함수는 입력신호의 총합이 활성화를 일으키는지를 정하는 역활을 합니다.

위의 함수는 가중치가 곱해진 입력신호의 총합을 계산하고 그 합을 활성화 함수에 입력해 결과를 내는 2단계로 처리됩니다.
그렇기 때문에 다음과 같은 2개의 식으로 나눌수 있습니다

가중치가 달린 입력신호와 편향의 총합을 계산하고 이를 a라합니다.
그리고 a를 함수 h()에 넣어 y를 출력하는 흐름입니다.
다음처럼 나타낼수 있습니다.


기존 뉴런의 원을 키우고 그안에 활성화 함수의 처리 과정을 넣어습니다.
즉 가중치 신호를 조합한 결과가 a라는 노드가되고 활성화 함수h()를 통과하여 y라는 노드로 변환되는 과정이 분명하게 나타나 있습니다.

*왼쪽은 일반적인 뉴런,오른쪽은 활성화 처리과정을 명시한 뉴런

활성화 함수

활성화 함수는 임계값을 경계로 출력을 바뀌는데 이런 함수를 계단함수라 합니다.
그렇기 떄문에 퍼셉트론에서는 활성화 함수로 계단 함수를 이용한다 라 할수 있습니다.
즉 활성화 함수로 쓸수 있는 여러 후보중에서 퍼셉트론은 계단함수를 사용하고 있습니다.


시그모이드 함수
신경망에서 자주 이용하는 활성화 함수인 시그모이드 함수를 나타낸 식입니다.

exp(-x)는 e⁻ˣ를 뜻하며 e는 자연상수로 2.7182..의값을 갖는 실수입니다.
예들 들어 시그모이드 함수에 1.0과 2.0을 입력하면 h(1.0)= 0.731...h(2.0)= 0.880...처럼 특정 값을 출력합니다.
신경망에서는 활성화 함수로 시그모이드 함수를 이용하여 신호를 변환하고 그 변환된 신호를 다음 뉴런에 전달합니다.

계단함수 구현

인수 x는 실수만 받아들입니다.
즉 step_function(3.0)은 되지만 배열을 인수로 넣을수 없습니다
ndarry스타일로 변경하려면

파이썬에서는
def step_function(x):
    y=x>0
    return y.astyoe(np.int)
으로 사용이 가능합니다
*/
/*계단함수의 그래프 */
/*시그모이드 함수 구현 */
/*시그모이드 함수 와 계단함수 비교 */
/*비선형 함슈 */
/*ReLU함수 */
/*다차원 배열의 계산 */
/*행렬의 곱 */
/*신경망 에서의 행렬 곱 */
/*3층 신경망 구현 */
/*출력충 설계 */
/*손글씨 숫자 읺식 */










fn step_function(x:i32)->i32{
  if x>0{
    return 1

  }else {
    return 0
  }
}
fn stet_function(x: Array1<f32>) -> Array1<f32> {
    x.map(|&val| if val > 0.0{ 1.0 } else { 0.0 })
}

/*
def stet_function(x):
    x=x>0
    return y.astype(np.int)

*/
pub fn main(){
let x= arr1(&[-5.0,5.0,0.1]);
let y = stet_function(x);

/*시그모이드 함수 구현
*/
/*다차원 배열 */

let a= arr1(&[1,2,3,4]);
print!("{}",a);

//차원의 수 확인
a.ndim();
//형상:원소 개로 구성
a.shape();

let b= arr2(&[[1,2],[3,4],[5,6]]);
println!("{}",b);
b.ndim();
b.shape();




}
//시그모이드 


fn sigmoid(){

}